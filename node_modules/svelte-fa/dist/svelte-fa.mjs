import { SvelteComponent, init, safe_not_equal, svg_element, attr, insert, append, detach, empty, noop } from 'svelte/internal';

/* src\fa.svelte generated by Svelte v3.29.7 */

function create_if_block(ctx) {
	let svg;
	let g1;
	let g0;
	let svg_viewBox_value;

	function select_block_type(ctx, dirty) {
		if (typeof /*i*/ ctx[8][4] == "string") return create_if_block_1;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			svg = svg_element("svg");
			g1 = svg_element("g");
			g0 = svg_element("g");
			if_block.c();
			attr(g0, "transform", /*transform*/ ctx[10]);
			attr(g1, "transform", "translate(256 256)");
			attr(svg, "id", /*id*/ ctx[1]);
			attr(svg, "class", /*clazz*/ ctx[0]);
			attr(svg, "style", /*s*/ ctx[9]);
			attr(svg, "viewBox", svg_viewBox_value = `0 0 ${/*i*/ ctx[8][0]} ${/*i*/ ctx[8][1]}`);
			attr(svg, "aria-hidden", "true");
			attr(svg, "role", "img");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, g1);
			append(g1, g0);
			if_block.m(g0, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(g0, null);
				}
			}

			if (dirty & /*transform*/ 1024) {
				attr(g0, "transform", /*transform*/ ctx[10]);
			}

			if (dirty & /*id*/ 2) {
				attr(svg, "id", /*id*/ ctx[1]);
			}

			if (dirty & /*clazz*/ 1) {
				attr(svg, "class", /*clazz*/ ctx[0]);
			}

			if (dirty & /*s*/ 512) {
				attr(svg, "style", /*s*/ ctx[9]);
			}

			if (dirty & /*i*/ 256 && svg_viewBox_value !== (svg_viewBox_value = `0 0 ${/*i*/ ctx[8][0]} ${/*i*/ ctx[8][1]}`)) {
				attr(svg, "viewBox", svg_viewBox_value);
			}
		},
		d(detaching) {
			if (detaching) detach(svg);
			if_block.d();
		}
	};
}

// (124:8) {:else}
function create_else_block(ctx) {
	let path0;
	let path0_d_value;
	let path0_fill_value;
	let path0_fill_opacity_value;
	let path1;
	let path1_d_value;
	let path1_fill_value;
	let path1_fill_opacity_value;

	return {
		c() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr(path0, "d", path0_d_value = /*i*/ ctx[8][4][0]);
			attr(path0, "fill", path0_fill_value = /*secondaryColor*/ ctx[4] || /*color*/ ctx[2] || "currentColor");

			attr(path0, "fill-opacity", path0_fill_opacity_value = /*swapOpacity*/ ctx[7] != false
			? /*primaryOpacity*/ ctx[5]
			: /*secondaryOpacity*/ ctx[6]);

			attr(path0, "transform", "translate(-256 -256)");
			attr(path1, "d", path1_d_value = /*i*/ ctx[8][4][1]);
			attr(path1, "fill", path1_fill_value = /*primaryColor*/ ctx[3] || /*color*/ ctx[2] || "currentColor");

			attr(path1, "fill-opacity", path1_fill_opacity_value = /*swapOpacity*/ ctx[7] != false
			? /*secondaryOpacity*/ ctx[6]
			: /*primaryOpacity*/ ctx[5]);

			attr(path1, "transform", "translate(-256 -256)");
		},
		m(target, anchor) {
			insert(target, path0, anchor);
			insert(target, path1, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*i*/ 256 && path0_d_value !== (path0_d_value = /*i*/ ctx[8][4][0])) {
				attr(path0, "d", path0_d_value);
			}

			if (dirty & /*secondaryColor, color*/ 20 && path0_fill_value !== (path0_fill_value = /*secondaryColor*/ ctx[4] || /*color*/ ctx[2] || "currentColor")) {
				attr(path0, "fill", path0_fill_value);
			}

			if (dirty & /*swapOpacity, primaryOpacity, secondaryOpacity*/ 224 && path0_fill_opacity_value !== (path0_fill_opacity_value = /*swapOpacity*/ ctx[7] != false
			? /*primaryOpacity*/ ctx[5]
			: /*secondaryOpacity*/ ctx[6])) {
				attr(path0, "fill-opacity", path0_fill_opacity_value);
			}

			if (dirty & /*i*/ 256 && path1_d_value !== (path1_d_value = /*i*/ ctx[8][4][1])) {
				attr(path1, "d", path1_d_value);
			}

			if (dirty & /*primaryColor, color*/ 12 && path1_fill_value !== (path1_fill_value = /*primaryColor*/ ctx[3] || /*color*/ ctx[2] || "currentColor")) {
				attr(path1, "fill", path1_fill_value);
			}

			if (dirty & /*swapOpacity, secondaryOpacity, primaryOpacity*/ 224 && path1_fill_opacity_value !== (path1_fill_opacity_value = /*swapOpacity*/ ctx[7] != false
			? /*secondaryOpacity*/ ctx[6]
			: /*primaryOpacity*/ ctx[5])) {
				attr(path1, "fill-opacity", path1_fill_opacity_value);
			}
		},
		d(detaching) {
			if (detaching) detach(path0);
			if (detaching) detach(path1);
		}
	};
}

// (118:8) {#if typeof i[4] == 'string'}
function create_if_block_1(ctx) {
	let path;
	let path_d_value;
	let path_fill_value;

	return {
		c() {
			path = svg_element("path");
			attr(path, "d", path_d_value = /*i*/ ctx[8][4]);
			attr(path, "fill", path_fill_value = /*color*/ ctx[2] || /*primaryColor*/ ctx[3] || "currentColor");
			attr(path, "transform", "translate(-256 -256)");
		},
		m(target, anchor) {
			insert(target, path, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*i*/ 256 && path_d_value !== (path_d_value = /*i*/ ctx[8][4])) {
				attr(path, "d", path_d_value);
			}

			if (dirty & /*color, primaryColor*/ 12 && path_fill_value !== (path_fill_value = /*color*/ ctx[2] || /*primaryColor*/ ctx[3] || "currentColor")) {
				attr(path, "fill", path_fill_value);
			}
		},
		d(detaching) {
			if (detaching) detach(path);
		}
	};
}

function create_fragment(ctx) {
	let if_block_anchor;
	let if_block = /*i*/ ctx[8][4] && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*i*/ ctx[8][4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { class: clazz = "" } = $$props;
	let { id = "" } = $$props;
	let { style = "" } = $$props;
	let { icon } = $$props;
	let { fw = false } = $$props;
	let { flip = false } = $$props;
	let { pull = false } = $$props;
	let { rotate = false } = $$props;
	let { size = false } = $$props;
	let { color = "" } = $$props;
	let { primaryColor = "" } = $$props;
	let { secondaryColor = "" } = $$props;
	let { primaryOpacity = 1 } = $$props;
	let { secondaryOpacity = 0.4 } = $$props;
	let { swapOpacity = false } = $$props;
	let i;
	let s;
	let transform;

	$$self.$$set = $$props => {
		if ("class" in $$props) $$invalidate(0, clazz = $$props.class);
		if ("id" in $$props) $$invalidate(1, id = $$props.id);
		if ("style" in $$props) $$invalidate(11, style = $$props.style);
		if ("icon" in $$props) $$invalidate(12, icon = $$props.icon);
		if ("fw" in $$props) $$invalidate(13, fw = $$props.fw);
		if ("flip" in $$props) $$invalidate(14, flip = $$props.flip);
		if ("pull" in $$props) $$invalidate(15, pull = $$props.pull);
		if ("rotate" in $$props) $$invalidate(16, rotate = $$props.rotate);
		if ("size" in $$props) $$invalidate(17, size = $$props.size);
		if ("color" in $$props) $$invalidate(2, color = $$props.color);
		if ("primaryColor" in $$props) $$invalidate(3, primaryColor = $$props.primaryColor);
		if ("secondaryColor" in $$props) $$invalidate(4, secondaryColor = $$props.secondaryColor);
		if ("primaryOpacity" in $$props) $$invalidate(5, primaryOpacity = $$props.primaryOpacity);
		if ("secondaryOpacity" in $$props) $$invalidate(6, secondaryOpacity = $$props.secondaryOpacity);
		if ("swapOpacity" in $$props) $$invalidate(7, swapOpacity = $$props.swapOpacity);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*icon*/ 4096) {
			 $$invalidate(8, i = icon && icon.icon || [0, 0, "", [], ""]);
		}

		if ($$self.$$.dirty & /*fw, pull, size, style*/ 174080) {
			 {
				let float;
				let width;
				const height = "1em";
				let lineHeight;
				let fontSize;
				let textAlign;
				let verticalAlign = "-.125em";
				const overflow = "visible";

				if (fw) {
					textAlign = "center";
					width = "1.25em";
				}

				if (pull) {
					float = pull;
				}

				if (size) {
					if (size == "lg") {
						fontSize = "1.33333em";
						lineHeight = ".75em";
						verticalAlign = "-.225em";
					} else if (size == "xs") {
						fontSize = ".75em";
					} else if (size == "sm") {
						fontSize = ".875em";
					} else {
						fontSize = size.replace("x", "em");
					}
				}

				const styleObj = {
					float,
					width,
					height,
					"line-height": lineHeight,
					"font-size": fontSize,
					"text-align": textAlign,
					"vertical-align": verticalAlign,
					overflow
				};

				let styleStr = "";

				for (const prop in styleObj) {
					if (styleObj[prop]) {
						styleStr += `${prop}:${styleObj[prop]};`;
					}
				}

				$$invalidate(9, s = styleStr + style);
			}
		}

		if ($$self.$$.dirty & /*flip, rotate*/ 81920) {
			 {
				let t = "";

				if (flip) {
					let flipX = 1;
					let flipY = 1;

					if (flip == "horizontal") {
						flipX = -1;
					} else if (flip == "vertical") {
						flipY = -1;
					} else {
						flipX = flipY = -1;
					}

					t += ` scale(${flipX} ${flipY})`;
				}

				if (rotate) {
					t += ` rotate(${rotate} 0 0)`;
				}

				$$invalidate(10, transform = t);
			}
		}
	};

	return [
		clazz,
		id,
		color,
		primaryColor,
		secondaryColor,
		primaryOpacity,
		secondaryOpacity,
		swapOpacity,
		i,
		s,
		transform,
		style,
		icon,
		fw,
		flip,
		pull,
		rotate,
		size
	];
}

class Fa extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			class: 0,
			id: 1,
			style: 11,
			icon: 12,
			fw: 13,
			flip: 14,
			pull: 15,
			rotate: 16,
			size: 17,
			color: 2,
			primaryColor: 3,
			secondaryColor: 4,
			primaryOpacity: 5,
			secondaryOpacity: 6,
			swapOpacity: 7
		});
	}
}

export default Fa;
